[TOC]



# 算法

## 两种算法的比较

假设我们需要算出1-100的和，一种最简单的写法是:

```c
int i = 1, sum = 0, n = 100;
for(i; i <= n; i++){
sum = sum + í;
}
printf ("%.d", sum);
```

但是这样的写法是最节约时间的吗？	答案是否定的。

其实我们早在小学就接触到了一种更简单的算法

```
sum = 1 + 2 + 3 + ... + 100
sum = 100 + 99 + 98 + ... + 1
2 * sum = 101 + 101 + 101 + ... + 101
sum = 101 * 100 / 2
```

用程序实现：

```c
sum = 0, n = 100;
sum = (1 + n) * n / 2;
printf ("%.d", sum);
```

相比于最开始用for循环的写法，这种写法明显更加的节约时间。for循环需要运行n次加法运算。

## 算法的特性

算法具有五个基本特性 : 输入、输出 、 有穷性、确定性和可行性。

**输入输出：**算法具有零个或多个输入，至少有一个或多个输出

**有穷性:**指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成

**确定性:**算法的每一步骤都具有确定的含义，不会出现二义性 。 

**可行性:**算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成 。 

## 算法设计的要求

**正确性:**算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案 。

**可读性:** 算法设计的另一目的是为了便于阅读、理解和交流

**健壮性:**当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果 

**时间效率高和存储量低：**设计算法应该尽量满足时间效率高和存储量低的需求 

## 算法效率的度量方法

**事后统计方法：**这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

但是这种方法具有很大的缺陷：

- 必须依据算法实现编制好程序，这往往需要大量的时间和精力。
- 在不同的机器上得到的结果可能不一样
- 数据规模难以判断

综上，这种方法我们不予采纳

**事前分析估算方法：**在计算机程序编制前，依据统计方法对算法进行估算 。

一个高级程序语言编写的程序在运行时消耗的时间取决于以下因素：

1. 算法采用的策略、方法	（算法好坏）
2. 编译产生的代码质量        （软件）
3. 问题的输入规模               （数据规模）
4. 机器执行指令的速度        （硬件性能）

再次拿回最开始提到的例子：

```c
// 1
int i = 1, sum = 0, n = 100;  // 执行1次
for(i; i <= n; i++){		 // 执行 n+1 次
sum = sum + í;			     // 执行n次
}
printf ("%.d", sum);		 // 执行1次
```

```c
// 2
sum = 0, n = 100;			// 执行1次
sum = (1 + n) * n / 2;		// 执行1次
printf ("%.d", sum);		// 执行1次
```

第一种算法：执行了 1 + (n+1) + n + 1 次 =2n + 3 次

第二种算法：只执行了3次

这样子对比，两种算法的优劣程度高下立现。

我们延伸上面的例子：

```c
int i, j, x = 0, sum = 0, n = 100;	// 执行1次
for(i = 1; i <= n; i++){
    for(j = 1; j <= n; j++){
        x++;					  // 执行 n*n 次
        sum = sum + x;
    }
}
printf("%d", sum);				   // 执行1次
```

在这个程序中，i从1到100，每次j都会循环100次，整体就是执行了100^2次。此时你会看到，测定运行时间最可靠的方法就是计算对运行时间有消耗的基本操作的执行次数 ，运行时间与这个计数成正比 。

**最终，在分析程序的运行时间时，最重要的是把程序看成是强立于程序设计语言的算法或一系列步骤。**

## 函数的渐近增长

假设两个算法的输入规模都是n，算法 A 要做 2n + 3 次操作，你可以理解为先有一个n次的循环，执行完成后，再有一个 n 次循环，最后有三次赋值或运算，共 2n + 3 次操作。算法 B 要做 3n + 1 次操作。你觉得它们谁更快呢?

准确的说，答案是不一定的

|  次数   | 算法A （2n + 3) | 算法A'（2n） | 算法B（3n+1） | 算法B'（3n） |
| :-----: | :-------------: | :----------: | :-----------: | :----------: |
|  n =1   |        5        |      2       |       4       |      3       |
|  n =2   |        7        |      4       |       7       |      6       |
|  n =3   |        9        |      6       |      10       |      9       |
| n = 10  |       23        |      20      |      31       |      30      |
| n = 100 |       203       |     200      |      301      |     300      |

**某个算法，随着 n 的增大，它会越来越优于另一算法，或者越来越差于另一算法。**

## 算法时间复杂度

定义：进行算法分析时，语句总的执行此时T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。算法的时间复杂度也就是时间量度，记作T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

也就是用大O来体现算法时间复杂度。称之为**大O记法**

### 推导大O阶方法

**推导大 O 阶 :**

1. 用常数1取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数得到的结果建设大O阶

例子：

```c
int sum = 0, n = 100;
sum = (1+n)*n/2;
printf("%d", sum);
```

**时间复杂度应该是O(1)** 

这个算法的运行次数函数是 f (n) =3  根据我们推导大O阶的方法，第一步就是把常数项 3 改为 1 。保留最高项时，发现并没有最高项，所以时间复杂度就是O(1).

即使是分支结构（不包含循环），时间复杂度也都是O(1) 因为无论真假，执行次数都是恒定的，不会随着n的变大而发生变化。

### 线性阶

**其实分析算法复杂度，关键在于分析循环结构**

```c
int i;
for(i=0; i<n; i++){
	/* 时间复杂度为O(1)的程序步骤序列 */
}
```

这段代码的时间复杂度为O(n)。因为循环体中的代码要执行n次。

### 对数阶

分析代码：

```c
int count = 1;
while(count < n){
	count = count * 2;
}
```

由于count*2之后。距离n更近了，也就是说有多少个2相乘后大于n就会退出循环。也就是2<sup>x</sup> = n 得到 x = log<sub>2</sub>n。所以这个循环的时间复杂度是O(logn)

### 平方阶

分析代码：

```c
int i, j;
for(i=0; i<n; i++){
	for(j=0; j<n; j++){
		/* 时间复杂度为O(1)的程序步骤序列 */
	}
}
```

内循环之前分析过，时间复杂度是O(n)，对于外层的循环不过是这个把这个时间复杂度为O(1)的语句再循环n次。所以时间复杂度为O(n<sup>2</sup>)

下面我把上面的代码改一下：

```c
int i, j;
for(i=0; i<m; i++){
	for(j=0; j<n; j++){
		/* 时间复杂度为O(1)的程序步骤序列 */
	}
}
```

这个代码的时间复杂度是O(m*n).

所以我们可以总结得出，循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。

再变一下：

```c
int i, j;
for(i=0; i<m; i++){
	for(j=i; j<n; j++){
		/* 时间复杂度为O(1)的程序步骤序列 */
	}
}
```

由于i=0时，内循环执行了n次，i=1时，执行n-1次。所以总的执行次数：

n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 = n<sup>2</sup>/2 + n/2

用之前的推到方法：

1. 没有常数所以不予考虑。
2. 保留最高阶—— n<sup>2</sup>/2 
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常数得到的结果建设大O阶

所以时间复杂度为O(n<sup>2</sup>)

再聊一个方法调用的：

```c
int i, j;
for(i=0; i<n; i++){
	function(i);
}

void function(int count){
	print(count);
}
```

函数function里面的时间复杂度是O(1),所以整体的时间复杂度为O(n)

复杂一点：

```c
int i, j;
for(i=0; i<n; i++){
	function(i);
}

void function(int count){
	int j;
    for(j=count; j<n; j++){
        /* 时间复杂度为O(1)的程序步骤序列 */
    }
}
```

其实和刚才的例子一样，只不过把循环放在了函数中。时间复杂度是O(n<sup>2</sup>)

一个复杂的：

```c
n++;					 /* 执行次数为1 */
function(n);			  /* 执行次数为n */
int i, j;
for(i=0; i<n; i++){		  /* 执行次数为n^2 */
	function(i);
}
for (i=0; i<n; j++){	  /* 执行次数为 n(n+1)/2 */
	for(j=i; j<n; j++){
	 	/* 时间复杂度为O(1)的程序步骤序列 */
	}
}
```

执行次数为：f(n) = 1 + n + n<sup>2</sup> + n(n+1)/2 = 3n<sup>2</sup>/2 +3n/2 + 1

可以推理出 时间复杂度是O(n<sup>2</sup>)

就做题来讲：我自己总结的一个省事的方法就是，先找到嵌套最多的循环，直接分析这个循环里面的复杂度。**但是需要注意的是：算法复杂度还会受到其他因素的影响 比如：分支语句、递归等等。因此，在分析算法复杂度时，需要综合考虑所有可能影响复杂度的因素，而不仅仅是一个循环。但是简单的情况还是可以用上面的方法的**

## 常见的时间复杂度

O(1) < O(log<sub>n</sub>) < O(n) < O(n logn) < O(n<sup>2</sup>) < O(n<sup>3</sup>) < O(2<sup>n</sup>) < O(n!) < O(n<sup>n</sup>)

## 最坏情况与平均情况

聊个现实的例子，当你在很多个柜子中找东西的时候，可能第一个柜子里就可以找到，也可能翻到了最后一个柜子才找到。

回到代码中，比如查找一个有n个随机数字数组中的某个数字，最好的情况是第一个数字就是，那么这个情况的时间复杂度是O(1),但如果是最后一个位置，时间复杂度就是O(n).

**最坏情况是运行时间的一种保证，在应用中，这是一种最重要的需求，通常情况下，除非特定，我们提到的运行时间都是最坏情况的运行时间。**

**平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。**

**一般没有特殊说明的情况下，都是最坏时间复杂度**

## 算法空间复杂度

**算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n)) 其中 n为问题的规模 f(n)为语句关于n所占存储空间的函数**

事实上 空间换时间是一种常见的技巧，但是至于用的好不好 就要看你用在什么地方了。

通常： 时间复杂度来指运行时间的需求，空间复杂度指空间需求。当不用限定词使用复杂度的时候指时间复杂度。









